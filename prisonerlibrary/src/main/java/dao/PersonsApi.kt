/**
 * Ascom Prisoner API
 * This is the Ascom REST Interface for Locations, Users, Persons and Appointments. You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).
 *
 * OpenAPI spec version: 1.0.0
 * Contact: alessandro.marra@ascom.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import com.ascom.prisonerlibrary.model.AppointmentId
import com.ascom.prisonerlibrary.model.Person
import com.ascom.prisonerlibrary.model.PersonBasic
import com.ascom.prisonerlibrary.model.PersonLocation
import infastructure.*

class PersonsApi(
    basePath: kotlin.String = "https://labama.aw1.ch/Prison/api/v1",
    sessionId: String
) : ApiClient(basePath, sessionId) {

    /**
     * Get an array of Persons by it&#x27;s LocationId
     *
     * @param locationId Id of the Location
     * @param userId Id of the User (optional)
     * @return kotlin.Array<Person>
     */
    @Suppress("UNCHECKED_CAST")
    fun personsByLocationIdLocationIdGet(
        locationId: kotlin.Int,
        userId: kotlin.Int? = null
    ): kotlin.Array<Person> {
        val localVariableQuery: MultiValueMap = mapOf("userId" to listOf("$userId"))
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/persons/byLocationId/{locationId}".replace("{" + "locationId" + "}", "$locationId"),
            query = localVariableQuery
        )
        val response = request<kotlin.Array<Person>>(
            localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Person>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException(
                (response as ClientError<*>).body as? String ?: "Client error"
            )
            ResponseType.ServerError -> throw ServerException(
                (response as ServerError<*>).message ?: "Server error"
            )
        }
    }

    /**
     * Get a Persons by Cell NFC RfId
     *
     * @param rfId Id of the NFC that needs to be send to retrieve the location
     * @param userId Id of the User (optional)
     * @return kotlin.Array<Person>
     */
    @Suppress("UNCHECKED_CAST")
    fun personsByRfIdRfIdGet(
        rfId: kotlin.String,
        userId: kotlin.Int? = null
    ): kotlin.Array<Person> {
        val localVariableQuery: MultiValueMap = mapOf("userId" to listOf("$userId"))
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/persons/byRfId/{rfId}".replace("{" + "rfId" + "}", "$rfId"),
            query = localVariableQuery
        )
        val response = request<kotlin.Array<Person>>(
            localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Person>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException(
                (response as ClientError<*>).body as? String ?: "Client error"
            )
            ResponseType.ServerError -> throw ServerException(
                (response as ServerError<*>).message ?: "Server error"
            )
        }
    }

    /**
     * Get a list of Persons
     *
     * @param userId Id of the User (optional)
     * @param offset The number of items to skip before starting to collect the result set (optional)
     * @param limit The numbers of items to return (optional)
     * @return kotlin.Array<Person>
     */
    @Suppress("UNCHECKED_CAST")
    fun personsGet(
        userId: kotlin.Int? = null,
        offset: kotlin.Int? = null,
        limit: kotlin.Int? = null
    ): kotlin.Array<Person> {
        val localVariableQuery: MultiValueMap = mapOf(
            "userId" to listOf("$userId"),
            "offset" to listOf("$offset"),
            "limit" to listOf("$limit")
        )
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/persons", query = localVariableQuery
        )
        val response = request<kotlin.Array<Person>>(
            localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Person>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException(
                (response as ClientError<*>).body as? String ?: "Client error"
            )
            ResponseType.ServerError -> throw ServerException(
                (response as ServerError<*>).message ?: "Server error"
            )
        }
    }

    /**
     * Get a Lite list of Persons
     *
     * @param userId Id of the User (optional)
     * @param offset The number of items to skip before starting to collect the result set (optional)
     * @param limit The numbers of items to return (optional)
     * @return kotlin.Array<PersonBasic>
     */
    @Suppress("UNCHECKED_CAST")
    fun personsLiteGet(
        userId: kotlin.Int? = null,
        offset: kotlin.Int? = null,
        limit: kotlin.Int? = null
    ): kotlin.Array<PersonBasic> {
        val localVariableQuery: MultiValueMap = mapOf(
            "userId" to listOf("$userId"),
            "offset" to listOf("$offset"),
            "limit" to listOf("$limit")
        )
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/personsLite", query = localVariableQuery
        )
        val response = request<kotlin.Array<PersonBasic>>(
            localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<PersonBasic>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException(
                (response as ClientError<*>).body as? String ?: "Client error"
            )
            ResponseType.ServerError -> throw ServerException(
                (response as ServerError<*>).message ?: "Server error"
            )
        }
    }

    /**
     * Get a Person by it&#x27;s Id
     *
     * @param personId Id of the Person
     * @param userId Id of the User (optional)
     * @return Person
     */
    @Suppress("UNCHECKED_CAST")
    fun personsPersonIdGet(personId: kotlin.String, userId: kotlin.Int? = null): Person {
        val localVariableQuery: MultiValueMap = mapOf("userId" to listOf("$userId"))
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/persons/{personId}".replace("{" + "personId" + "}", "$personId"),
            query = localVariableQuery
        )
        val response = request<Person>(
            localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Person
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException(
                (response as ClientError<*>).body as? String ?: "Client error"
            )
            ResponseType.ServerError -> throw ServerException(
                (response as ServerError<*>).message ?: "Server error"
            )
        }
    }

    /**
     * Get Person Locations by it&#x27;s Id
     *
     * @param personId Id of the Person
     * @param userId Id of the User (optional)
     * @return kotlin.Array<PersonLocation>
     */
    @Suppress("UNCHECKED_CAST")
    fun personsPersonIdLocationsGet(
        personId: kotlin.String,
        userId: kotlin.Int? = null
    ): kotlin.Array<PersonLocation> {
        val localVariableQuery: MultiValueMap = mapOf("userId" to listOf("$userId"))
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/persons/{personId}/locations".replace("{" + "personId" + "}", "$personId"),
            query = localVariableQuery
        )
        val response = request<kotlin.Array<PersonLocation>>(
            localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<PersonLocation>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException(
                (response as ClientError<*>).body as? String ?: "Client error"
            )
            ResponseType.ServerError -> throw ServerException(
                (response as ServerError<*>).message ?: "Server error"
            )
        }
    }

    /**
     * Set Person Location by it&#x27;s Id
     *
     * @param personId Id of the Person
     * @param userId Id of the User (optional)
     * @param appointmentId If an Id is entered the Location update is connected to an appointment, if Id is empty, this is only a person move (optional)
     * @param temporaryLocationId If an Id &gt; 0 is entered the Temporary Location is added, if 0 or empty the temporary location is removed (optional)
     * @return AppointmentId
     */
    @Suppress("UNCHECKED_CAST")
    fun personsPersonIdTemporaryLocationPut(
        personId: kotlin.String,
        userId: kotlin.Int? = null,
        appointmentId: kotlin.String? = null,
        temporaryLocationId: kotlin.Int? = null
    ): AppointmentId {
        val localVariableQuery: MultiValueMap = mapOf(
            "userId" to listOf("$userId"),
            "AppointmentId" to listOf("$appointmentId"),
            "TemporaryLocationId" to listOf("$temporaryLocationId")
        )
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/persons/{personId}/temporaryLocation".replace("{" + "personId" + "}", "$personId"),
            query = localVariableQuery
        )
        val response = request<AppointmentId>(
            localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AppointmentId
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException(
                (response as ClientError<*>).body as? String ?: "Client error"
            )
            ResponseType.ServerError -> throw ServerException(
                (response as ServerError<*>).message ?: "Server error"
            )
        }
    }
}
