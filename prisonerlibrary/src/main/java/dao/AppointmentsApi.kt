/**
 * Ascom Prisoner API
 * This is the Ascom REST Interface for Locations, Users, Persons and Appointments. You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).
 *
 * OpenAPI spec version: 1.0.0
 * Contact: alessandro.marra@ascom.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package dao


import com.ascom.prisonerlibrary.model.Appointment
import com.ascom.prisonerlibrary.model.AppointmentState
import infastructure.*

class AppointmentsApi(
    basePath: kotlin.String = "https://labama.aw1.ch/Prison/api/v1",
    sessionId: String
) : ApiClient(basePath, sessionId) {

    /**
     * Get an appointment by it&#x27;s Id
     *
     * @param appointmentId Id of the Appointment
     * @param userId Id of the User (optional)
     * @return Appointment
     */
    @Suppress("UNCHECKED_CAST")
    fun appointmentsAppointmentIdGet(
        appointmentId: kotlin.String,
        userId: kotlin.Int? = null
    ): Appointment {
        val localVariableQuery: MultiValueMap = mapOf("userId" to listOf("$userId"))
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/appointments/{appointmentId}".replace("{" + "appointmentId" + "}", "$appointmentId"),
            query = localVariableQuery
        )
        val response = request<Appointment>(
            localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Appointment
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException(
                (response as ClientError<*>).body as? String ?: "Client error"
            )
            ResponseType.ServerError -> throw ServerException(
                (response as ServerError<*>).message ?: "Server error"
            )
        }
    }

    /**
     * Update an appointment by it&#x27;s Id
     *
     * @param appointmentId Id of the Appointment
     * @param state The appointment state
     * @param userId Id of the User (optional)
     * @param temporaryLocationId If an Id &gt; 0 is entered the Temporary Location is added, if 0 or empty the temporary location is removed (optional)
     * @return void
     */
    fun appointmentsAppointmentIdPut(
        appointmentId: kotlin.String,
        state: AppointmentState,
        userId: kotlin.Int? = null,
        temporaryLocationId: kotlin.Int? = null
    ): Unit {
        val localVariableQuery: MultiValueMap = mapOf(
            "userId" to listOf("$userId"),
            "State" to listOf("$state"),
            "TemporaryLocationId" to listOf("$temporaryLocationId")
        )
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/appointments/{appointmentId}".replace("{" + "appointmentId" + "}", "$appointmentId"),
            query = localVariableQuery
        )
        val response = request<Any?>(
            localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException(
                (response as ClientError<*>).body as? String ?: "Client error"
            )
            ResponseType.ServerError -> throw ServerException(
                (response as ServerError<*>).message ?: "Server error"
            )
        }
    }

    /**
     * Get a list of Appointments for the specific person
     *
     * @param personId Id of the Person
     * @param userId Id of the User (optional)
     * @param offset The number of items to skip before starting to collect the result set (optional)
     * @param limit The numbers of items to return (optional)
     * @return kotlin.Array<Appointment>
     */
    @Suppress("UNCHECKED_CAST")
    fun appointmentsByPersonIdPersonIdGet(
        personId: kotlin.String,
        userId: kotlin.Int? = null,
        offset: kotlin.Int? = null,
        limit: kotlin.Int? = null
    ): kotlin.Array<Appointment> {
        val localVariableQuery: MultiValueMap = mapOf(
            "userId" to listOf("$userId"),
            "offset" to listOf("$offset"),
            "limit" to listOf("$limit")
        )
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/appointments/byPersonId/{personId}".replace("{" + "personId" + "}", "$personId"),
            query = localVariableQuery
        )
        val response = request<kotlin.Array<Appointment>>(
            localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Appointment>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException(
                (response as ClientError<*>).body as? String ?: "Client error"
            )
            ResponseType.ServerError -> throw ServerException(
                (response as ServerError<*>).message ?: "Server error"
            )
        }
    }

    /**
     * Add a Flexible Appointment for a Person
     *
     * @param personId Id of the Person
     * @param type The appointment type
     * @param locationId The appointment location id
     * @param userId Id of the User (optional)
     * @return void
     */
    fun appointmentsByPersonIdPersonIdPost(
        personId: kotlin.String,
        type: kotlin.String,
        locationId: kotlin.Int,
        userId: kotlin.Int? = null
    ): Unit {
        val localVariableQuery: MultiValueMap = mapOf(
            "userId" to listOf("$userId"),
            "Type" to listOf("$type"),
            "LocationId" to listOf("$locationId")
        )
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/appointments/byPersonId/{personId}".replace("{" + "personId" + "}", "$personId"),
            query = localVariableQuery
        )
        val response = request<Any?>(
            localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException(
                (response as ClientError<*>).body as? String ?: "Client error"
            )
            ResponseType.ServerError -> throw ServerException(
                (response as ServerError<*>).message ?: "Server error"
            )
        }
    }

    /**
     * Get a list of Appointments
     *
     * @param userId Id of the User (optional)
     * @param offset The number of items to skip before starting to collect the result set (optional)
     * @param limit The numbers of items to return (optional)
     * @return kotlin.Array<Appointment>
     */
    @Suppress("UNCHECKED_CAST")
    fun appointmentsGet(
        userId: kotlin.Int? = null,
        offset: kotlin.Int? = null,
        limit: kotlin.Int? = null
    ): kotlin.Array<Appointment> {
        val localVariableQuery: MultiValueMap = mapOf(
            "userId" to listOf("$userId"),
            "offset" to listOf("$offset"),
            "limit" to listOf("$limit")
        )
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/appointments", query = localVariableQuery
        )
        val response = request<kotlin.Array<Appointment>>(
            localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Appointment>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException(
                (response as ClientError<*>).body as? String ?: "Client error"
            )
            ResponseType.ServerError -> throw ServerException(
                (response as ServerError<*>).message ?: "Server error"
            )
        }
    }
}
